# Azure Pipelines CI/CD for COA ProjectKnowledge MCP Server
# Builds, tests, and publishes dotnet tool to Azure Artifacts
#
# Service Connection Requirements:
# - "COA NuGet Feed" for publishing to Azure Artifacts (required)
# - "NuGet.org - COA" for publishing to NuGet.org (optional)
#   To create: Azure DevOps > Project Settings > Service connections > New > NuGet
#   Set SKIP_NUGET_PUBLISH=true to skip NuGet.org publishing if connection unavailable

name: 'COA ProjectKnowledge MCP Server - $(Build.SourceBranchName) - $(Date:yyyyMMdd)$(Rev:.r)'

trigger:
  branches:
    include:
      - main
      - develop
      - release/*
  tags:
    include:
      - v*
  paths:
    exclude:
      - "**/*.md"
      - ".gitignore"
      - "docs/**"

pr:
  branches:
    include:
      - main
      - develop

pool:
  name: "Default" # Using local Windows agent pool

variables:
  buildConfiguration: "Release"
  dotnetSdkVersion: "9.x"
  # Base version
  majorVersion: 1
  minorVersion: 0
  # Auto-incrementing patch version - increments on every build
  # The counter is keyed by major.minor version, so it resets when those change
  patchVersion: $[counter(format('{0}.{1}', variables['majorVersion'], variables['minorVersion']), 0)]
  versionPrefix: "$(majorVersion).$(minorVersion).$(patchVersion)"
  versionSuffix: ""
  # Windows-specific settings
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  NUGET_PACKAGES: $(Pipeline.Workspace)\.nuget\packages
  # Release flag based on tags
  ${{ if startsWith(variables['Build.SourceBranch'], 'refs/tags/v') }}:
    isRelease: true
  ${{ else }}:
    isRelease: false

stages:
  - stage: Build
    displayName: "Build and Test"
    jobs:
      - job: BuildAndTest
        displayName: "Build, Test, and Pack"
        steps:
          - checkout: self
            fetchDepth: 0
            clean: true

          - powershell: |
              Write-Host "Agent Information:"
              Write-Host "=================="
              Write-Host "Agent Name: $env:AGENT_NAME"
              Write-Host "Agent OS: $env:AGENT_OS"
              Write-Host "Agent Version: $env:AGENT_VERSION"
              Write-Host "OS Version: $([System.Environment]::OSVersion.VersionString)"
              Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)"
              Write-Host "=================="
            displayName: "Display agent information"

          - task: Cache@2
            displayName: "Cache NuGet packages"
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/*.csproj,!**/bin/**,!**/obj/**'
              restoreKeys: |
                nuget | "$(Agent.OS)"
                nuget
              path: "$(NUGET_PACKAGES)"

          - powershell: |
              # Calculate version based on branch/tag
              $majorVersion = $(majorVersion)
              $minorVersion = $(minorVersion)
              $patchVersion = $(patchVersion)

              # Get the build counter for the current version
              $buildRevision = $env:BUILD_BUILDNUMBER.Split('.')[-1]

              Write-Host "Build Source Branch: $env:BUILD_SOURCEBRANCH"
              Write-Host "Build Reason: $env:BUILD_REASON"
              Write-Host "Patch Version (auto-incremented): $patchVersion"

              if ($env:BUILD_SOURCEBRANCH -match "^refs/tags/v(.*)") {
                  # Tag build - use the version from the tag
                  $version = $matches[1]
                  $versionSuffix = ""
                  Write-Host "Tag build detected. Version from tag: $version"
              }
              elseif ($env:BUILD_SOURCEBRANCH -eq "refs/heads/main") {
                  # Main branch - use auto-incremented patch version
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $versionSuffix = ""
                  Write-Host "Main branch build. Version: $version"
              }
              elseif ($env:BUILD_SOURCEBRANCH -match "^refs/heads/release/(.*)") {
                  # Release branch
                  $releaseName = $matches[1]
                  if ($releaseName -match "^(\d+)\.(\d+)") {
                      $majorVersion = $matches[1]
                      $minorVersion = $matches[2]
                  }
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $versionSuffix = "rc.$buildRevision"
                  Write-Host "Release branch build. Version: $version-$versionSuffix"
              }
              elseif ($env:BUILD_SOURCEBRANCH -eq "refs/heads/develop") {
                  # Develop branch - preview versions
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $versionSuffix = "preview.$buildRevision"
                  Write-Host "Develop branch build. Version: $version-$versionSuffix"
              }
              else {
                  # Feature branches or PRs
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $branchName = $env:BUILD_SOURCEBRANCHNAME -replace '[^a-zA-Z0-9]', ''
                  $versionSuffix = "alpha.$branchName.$buildRevision"
                  Write-Host "Feature branch build. Version: $version-$versionSuffix"
              }

              # Set pipeline variables
              Write-Host "##vso[task.setvariable variable=versionPrefix]$version"
              Write-Host "##vso[task.setvariable variable=versionSuffix]$versionSuffix"

              if ($versionSuffix) {
                  Write-Host "##vso[build.updatebuildnumber]$version-$versionSuffix"
                  Write-Host "Final version: $version-$versionSuffix"
              }
              else {
                  Write-Host "##vso[build.updatebuildnumber]$version"
                  Write-Host "Final version: $version"
              }
            displayName: "Calculate version number"
            name: VersionStep

          - powershell: |
              Write-Host "========================================="
              Write-Host "Package Version Information:"
              Write-Host "========================================="
              Write-Host "Major Version: $(majorVersion)"
              Write-Host "Minor Version: $(minorVersion)"
              Write-Host "Patch Version: $(patchVersion)"
              Write-Host "Version Prefix: $(versionPrefix)"
              Write-Host "Version Suffix: $(versionSuffix)"
              if ("$(versionSuffix)") {
                  Write-Host "Full Version: $(versionPrefix)-$(versionSuffix)"
              }
              else {
                  Write-Host "Full Version: $(versionPrefix)"
              }
              Write-Host "Counter Key: $(majorVersion).$(minorVersion)"
              Write-Host "========================================="
            displayName: "Display version information"

          - task: UseDotNet@2
            displayName: "Install .NET SDK"
            inputs:
              version: $(dotnetSdkVersion)
              includePreviewVersions: false

          - task: NodeTool@0
            displayName: "Install Node.js"
            inputs:
              versionSpec: '18.x'

          - task: NuGetAuthenticate@1
            displayName: 'Authenticate to NuGet feeds'

          - task: DotNetCoreCLI@2
            displayName: "Restore packages"
            inputs:
              command: "restore"
              projects: "**/*.csproj"
              feedsToUse: "select"
              vstsFeed: "COA"
              includeNuGetOrg: true

          - powershell: |
              # Prepare build/pack arguments based on version suffix
              $versionArgs = "-p:VersionPrefix=$(versionPrefix)"
              if ("$(versionSuffix)") {
                  $versionArgs += " -p:VersionSuffix=$(versionSuffix)"
              }
              Write-Host "##vso[task.setvariable variable=versionArguments]$versionArgs"
              Write-Host "Version arguments: $versionArgs"
            displayName: "Prepare version arguments"

          - task: DotNetCoreCLI@2
            displayName: "Build solution"
            inputs:
              command: "build"
              projects: "**/*.sln"
              arguments: "--configuration $(buildConfiguration) --no-restore $(versionArguments)"

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: "**/*Tests.csproj"
              arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage"'
              publishTestResults: true

          - task: PublishCodeCoverageResults@2
            displayName: "Publish code coverage"
            inputs:
              summaryFileLocation: '$(Agent.TempDirectory)\**\coverage.cobertura.xml'

          - powershell: |
              Write-Host "Build Artifact Staging Directory: $(Build.ArtifactStagingDirectory)"
              Write-Host "Creating packages directory..."
              New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)\packages"
            displayName: "Prepare package directory"

          - task: DotNetCoreCLI@2
            displayName: "Pack COA.ProjectKnowledge.McpServer"
            inputs:
              command: "pack"
              packagesToPack: "COA.ProjectKnowledge.McpServer/COA.ProjectKnowledge.McpServer.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: false  # Changed to false to ensure build happens
              versioningScheme: "off"
              arguments: "$(versionArguments) --no-restore"

          - powershell: |
              Write-Host "Checking generated packages..."
              Write-Host "======================================="
              Write-Host "Artifact staging directory contents:"
              if (Test-Path "$(Build.ArtifactStagingDirectory)") {
                  Get-ChildItem -Path "$(Build.ArtifactStagingDirectory)" -Recurse | ForEach-Object {
                      Write-Host "  $($_.FullName)"
                  }
              } else {
                  Write-Host "  Staging directory does not exist!"
              }
              
              Write-Host ""
              Write-Host "Packages directory contents:"
              if (Test-Path "$(Build.ArtifactStagingDirectory)\packages") {
                  $packages = Get-ChildItem -Path "$(Build.ArtifactStagingDirectory)\packages" -Filter "*.nupkg"
                  if ($packages.Count -gt 0) {
                      $packages | ForEach-Object {
                          Write-Host "  $($_.Name) - Size: $([math]::Round($_.Length / 1MB, 2)) MB"
                      }
                  } else {
                      Write-Host "  No .nupkg files found!"
                  }
              } else {
                  Write-Host "  Packages directory does not exist!"
              }
              Write-Host "======================================="
            displayName: "Debug: List generated packages"

          - powershell: |
              $packagesPath = "$(Build.ArtifactStagingDirectory)\packages"
              $hasPackages = (Test-Path $packagesPath) -and ((Get-ChildItem -Path $packagesPath -Filter "*.nupkg").Count -gt 0)
              Write-Host "##vso[task.setvariable variable=hasPackages]$hasPackages"
              Write-Host "Has packages to publish: $hasPackages"
            displayName: "Check if packages exist"

          - task: PublishBuildArtifacts@1
            displayName: "Publish artifacts"
            condition: eq(variables['hasPackages'], 'True')
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)\packages'
              ArtifactName: "packages"
              publishLocation: "Container"

          - script: |
              echo "##[warning]No packages were generated. Skipping artifact publishing."
              echo "##[section]Check the pack step logs above for issues."
            displayName: "Package Generation Warning"
            condition: eq(variables['hasPackages'], 'False')

  - stage: Publish
    displayName: "Publish to Azure DevOps"
    dependsOn: Build
    condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
    jobs:
      - job: PublishPackages
        displayName: "Publish to COA Feed"
        steps:
          - task: DownloadBuildArtifacts@1
            displayName: "Download artifacts"
            continueOnError: true
            inputs:
              buildType: "current"
              downloadType: "single"
              artifactName: "packages"
              downloadPath: "$(System.ArtifactsDirectory)"

          - powershell: |
              $artifactsPath = "$(System.ArtifactsDirectory)\packages"
              $hasPackages = (Test-Path $artifactsPath) -and ((Get-ChildItem -Path $artifactsPath -Filter "*.nupkg" -ErrorAction SilentlyContinue).Count -gt 0)
              Write-Host "##vso[task.setvariable variable=hasPackagesToPublish]$hasPackages"
              Write-Host "Has packages to publish: $hasPackages"
              if ($hasPackages) {
                  Write-Host "Packages found:"
                  Get-ChildItem -Path $artifactsPath -Filter "*.nupkg" | ForEach-Object {
                      Write-Host "  $($_.Name)"
                  }
              } else {
                  Write-Host "No packages found in artifacts directory"
              }
            displayName: "Check downloaded packages"

          - task: NuGetAuthenticate@1
            displayName: 'Authenticate to NuGet feed'
            condition: eq(variables['hasPackagesToPublish'], 'True')
            
          - task: DotNetCoreCLI@2
            displayName: "Push to COA Azure DevOps feed"
            condition: eq(variables['hasPackagesToPublish'], 'True')
            inputs:
              command: "push"
              packagesToPush: '$(System.ArtifactsDirectory)\packages\*.nupkg'
              nuGetFeedType: "internal"
              publishVstsFeed: "COA"
              allowPackageConflicts: true
              arguments: "--skip-duplicate"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          - script: |
              echo "##[warning]No packages were available to publish to the COA feed."
              echo "##[section]This usually means the pack step in the Build stage failed to generate .nupkg files."
              echo "##[section]Check the Build stage logs for pack step errors."
            displayName: "No Packages Warning"
            condition: eq(variables['hasPackagesToPublish'], 'False')

  # NuGet.org publishing stage (disabled until service connection is configured)
  # To enable: Create "NuGet.org - COA" service connection in Azure DevOps Project Settings
  # Then uncomment the stage below and remove this comment block
  #
  # - stage: PublishNuGet
  #   displayName: "Publish to NuGet.org"
  #   dependsOn: Build
  #   condition: and(succeeded(), eq(variables['isRelease'], true))
  #   jobs:
  #     - job: PublishToNuGet
  #       displayName: "Publish to NuGet.org (Release only)"
  #       steps:
  #         - task: DownloadBuildArtifacts@1
  #           displayName: "Download artifacts"
  #           inputs:
  #             buildType: "current"
  #             downloadType: "single"
  #             artifactName: "packages"
  #             downloadPath: "$(System.ArtifactsDirectory)"
  #
  #         - task: NuGetCommand@2
  #           displayName: "Push to NuGet.org"
  #           inputs:
  #             command: "push"
  #             packagesToPush: '$(System.ArtifactsDirectory)\packages\*.nupkg'
  #             nuGetFeedType: "external"
  #             publishFeedCredentials: "NuGet.org - COA"
  #             allowPackageConflicts: false